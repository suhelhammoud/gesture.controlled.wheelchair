import cv2

from application_commands import CMD

"""
class RoiBounds:

صف اساسي يمثل منطقة هامة في الصورة على شكل مستطيل في البرنامج له عدة خصائص بالاضافة إلى اجرائيات كثيرة تستخدم في تمثيل أجزاء مستطيلة من الصورة المدروسة
 كما تستخدم هذه الاجرائيات في دراسة علاقة هذه المستطيلات فيما بينها
 أهم الخصائص في هذا الصف هي احداثيات رؤوس هذا المستطيل بالنسبة للمحور x و المحور y
 و يمكن بشكل اختياري تحديد مركز هذا المستطيل كـ xc و yc
 أما الاجرائيات التي يحتويها هذا الصف فتوثيقها موجود في الكود المصدر بالتفصيل و باختصار هي 
 اجرائيات لتحديد العلاقة بين منطقتين ممثلتين بمستطيلين على الصورة
 هل هما على نفس المستوى الافقي أو الشاقولي, و أيهما باتجاه اليمين أو باتجاه اليسار أو بالاتجاه القطري يمين أسفل الصورة و هكذا
 إلى نهاية المقارنات
  
  كما يحتوي هذا الصف إلى اجرائيتين هامتين هما
      def is_valid_smile(left_eye, right_eye, smile):
اجرائية تحدد إذا كانت المناطق المكتشفة و التي تمثل العينين و الابتسامة هي مناطق تتبع لابتسامة صحيحة
و الابتسامة الصحيحة حسب هذه الاجرائية هي الابتسامة التي تقع فيها العينين على خط افقي واحد و العين اليمنى فيها إلى يمين العين اليسرى
و المستطيل المحيط بالابتسامة يقع تحت العينين في المنتصف

    def process_roibounds(roibound_eyes, roibound_smile, ref_roi):
هذه الاجرائية تقوم ,بعد التاكد من أن مواضع العينين و الابتسامة المكتشفة هي مواضع صحيحة, تقوم بتحديد مواضع العينين 
بالنسبة إلى نقطة مقارنة مرجعية ref_roi و اعتمادا على هذه التموضع النسبي يتم تحديد طبيعة الامر الذي يجب إرساله إلى دراة الاردوينو
 هل هو تقدم أم تراجع, يمين أم يسار الخ

"""

class RoiBounds:
    """
    Holds the coordinates of Region Of Interest ROI in the image
    Attributes:
        :x1: integer, x coordinate of the left side of ROI
        :x2: integer, x coordinate of the right side of ROI
        :y1: integer, y coordinate of the top side of ROI
        :y2: integer, y coordinate of the bottom side of ROI
        :xc: integer (optionl), x coordinate of the center of ROI
        :yc: integer (optionl), y coordinate of the center of ROI
    """

    def __init__(self, x1, y1, x2, y2, xc=None, yc=None):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        if xc is None:
            self.xc = (x1 + x2) / 2
        else:
            self.xc = xc
        if yc is None:
            self.yc = (y1 + y2) / 2
        else:
            self.yc = yc

    def __repr__(self):
        """

        :return: string representation of this object, suitable for printing and debugging.
        """
        return 'roi ({}, {}), ({}, {}), center ({}, {})'.format(
            self.x1, self.y1, self.x2, self.y2, self.xc, self.yc)

    def coordinates(self):
        """

        :return: tuple(x1, y1, x2, y2)
        """
        return (self.x1, self.y1, self.x2, self.y2)

    def translate(self, dx, dy):
        """
        Create new RoiBounds object from the current one but with value generated by shifting the
        center coordinates by (dx, dy) vector
        :param dx: integer, shift value for x axis
        :param dy: integer, shift value for y axis
        :return: new RoiBounds for the shifted coordinates center
        """
        return RoiBounds(dx + self.x1, dy + self.y1, dx + self.x2, dy + self.y2)

    def top_left(self):
        return (self.x1, self.y1)

    def bottom_right(self):
        return (self.x2, self.y2)

    def center(self):
        return (self.xc, self.yc)

    def is_upper_than(self, that):
        return self.y2 < that.y1

    def is_lower_than(self, that):
        return self.y1 > that.y2

    def is_same_level_h(self, that):
        """
        Compare this object with that one to see if they are at the same horizontal level
        :param that: RoiBounds object to compare with
        :return: boolean, true if this RoiBound object is with the same horizontal level with that Roibounds object
        """

        return not (self.is_lower_than(that)
                    or self.is_upper_than(that))

    def is_right_to(self, that):
        return self.x1 > that.x2

    def is_left_to(self, that):
        return self.x2 < that.x1

    def is_same_level_v(self, that):
        """
        Compare this object with that one to see if they are at the same vertical level
        :param that: RoiBounds object to compare with
        :return: boolean, true if this RoiBound object is with the same verticallevel with that Roibounds object
        """
        return not (self.is_right_to(that)
                    or self.is_left_to(that))

    def is_overlapping_with(self, that):
        return (self.is_same_level_h(that)
                and self.is_same_level_v(that))

    def is_top_left_to(self, that):
        return (self.is_left_to(that)
                and self.is_upper_than(that))

    def is_top_right_to(self, that):
        return (self.is_right_to(that)
                and self.is_upper_than(that))

    def is_lower_left_to(self, that):
        return (self.is_lower_than(that)
                and self.is_left_to(that))

    def is_lower_right_to(self, that):
        return (self.is_lower_than(that)
                and self.is_right_to(that))

    def roi(self, img):
        return RoiBounds.get_roi(img, self)

    @staticmethod
    def split_eyes(eyes):  # [e1, e2]
        """
        Decide which is the right eye and which is the left eye
        :param eyes: array of RoiBounds object representing eyes
        :return: tuple(left_eye, right_eye) if found, otherwise return (None, None)
        """
        if (len(eyes) != 2):
            return (None, None)
        one, two = eyes
        if one.is_overlapping_with(two):
            return (None, None)

        if (not one.is_same_level_h(two)
            or one.is_same_level_v(two)):
            return (None, None)

        if one.is_left_to(two):
            return (one, two)
        else:
            return (two, one)

    @staticmethod
    def process_roibounds(roibound_eyes, roibound_smile, ref_roi):
        """
        Process RoiBounds objects and decice what is the CMD command based on locations of objects
        :param roibound_eyes: list of RoiBounds of eyes in the image
        :param roibound_smile: list of RoiBounds of smiles in the image
        :param ref_roi: RoiBouns object of the center of the image, used for comparison with eyes and smile
        :return: CMD command based on the relative position of eyes and smile with the ref_roi box
        """
        if roibound_eyes is None or len(roibound_eyes) != 2:  # early exit if no two eyes in image
            return CMD.STOP

        left, right = RoiBounds.split_eyes(roibound_eyes)
        if left is None:
            return CMD.STOP

        if roibound_smile is None or len(roibound_smile) == 0:  # early exit if no one smile in image
            return CMD.NONE

        smile = roibound_smile[0]
        if RoiBounds.is_valid_smile(left, right, smile):
            # if RoiBounds.command_is_stop(left, right, smile, ref_roi):
            #     print "command is Stop"
            #     return CMD.STOP
            if RoiBounds.command_is_forward(left, right, smile, ref_roi):
                return CMD.FORWARD
            if RoiBounds.command_is_right(left, right, smile, ref_roi):
                return CMD.RIGHT
            if RoiBounds.command_is_left(left, right, smile, ref_roi):
                return CMD.LEFT
            if RoiBounds.command_is_backward(left, right, smile, ref_roi):
                return CMD.BACKWARD
        else:
            return CMD.NONE

    @staticmethod
    def is_valid_smile(left_eye, right_eye, smile):
        """
        Check if the eyes and smile are properly aligned
        :param left_eye: RoiBounds object of the left eye
        :param right_eye: RoiBounds object of the right eye
        :param smile: RoiBounds object of the smile
        :return: boolean, true if the RoiBounds are properly aligned
        """
        return (smile is not None
                and smile.is_lower_than(left_eye)
                and smile.is_lower_than(right_eye)
                and smile.is_same_level_v(left_eye)
                and smile.is_same_level_v(right_eye))

    @staticmethod
    def command_is_forward(left_eye, right_eye, smile, ref_roi):
        return left_eye.is_top_left_to(ref_roi) \
               and right_eye.is_top_right_to(ref_roi) \
               and smile.is_same_level_v(ref_roi)

    @staticmethod
    def command_is_backward(left_eye, right_eye, simle, ref_roi):
        return left_eye.is_left_to(ref_roi) \
               and right_eye.is_right_to(ref_roi) \
               and left_eye.is_same_level_h(ref_roi) \
               and right_eye.is_same_level_h(ref_roi)

    @staticmethod
    def command_is_left(left_eye, right_eye, simle, ref_roi):
        return (left_eye.is_top_left_to(ref_roi)
                and right_eye.is_same_level_v(ref_roi))

    @staticmethod
    def command_is_right(left_eye, right_eye, simle, ref_roi):
        return (right_eye.is_top_right_to(ref_roi)
                and left_eye.is_same_level_v(ref_roi))

    @staticmethod
    def command_is_stop(left_eye, right_eye, simle, ref_roi):
        # TODO: implement method
        pass
        return True

    @staticmethod
    def parse_command(left_eye, right_eye, simle, ref_roi):
        if RoiBounds.command_is_forward(left_eye, right_eye, simle, ref_roi):
            return CMD.FORWARD
        if RoiBounds.command_is_backward(left_eye, right_eye, simle, ref_roi):
            return CMD.BACKWARD
        if RoiBounds.command_is_right(left_eye, right_eye, simle, ref_roi):
            return CMD.RIGHT
        if RoiBounds.command_is_left(left_eye, right_eye, simle, ref_roi):
            return CMD.LEFT

        return CMD.STOP  # could not parse command be safe and stop

    @staticmethod
    def height_width(img):
        return img.shape[:2]

    @staticmethod
    def get_center_of_image(img):
        """return width, height"""
        height, width = RoiBounds.height_width(img)
        return width / 2, height / 2

    @staticmethod
    def center_roibound(image, dim):
        """ if dim =[size] get center , else [w0, h0, w1, h1]"""
        xc, yc = RoiBounds.get_center_of_image(image)
        if len(dim) == 1:
            size = dim[0]
            return RoiBounds(xc - size, yc - size, xc + size, yc + size, xc, yc)
        else:
            return RoiBounds(xc - dim[0], yc - dim[1], xc + dim[0], yc + dim[1], xc, yc)

    @staticmethod
    def get_one_image(v_path=None):
        """
        Take one frame from video stream defined by file path or web camera one
        :param v_path: string, (optional), file path of video file
        :return: one image frame taken from the provided video stream.
        """
        if v_path is None:
            v_path = 0
        cam = cv2.VideoCapture(v_path)
        ret, img = cam.read()
        return img

    @staticmethod
    def get_roi(img, roibound):
        """
        Crop image and get from it an area defined by roibound rectangle
        :param img:
        :param roibound: RoiBounds object hold the boundaries of roi
        :return: image of part defined by the roibound box
        """
        return img[roibound.y1:roibound.y2, roibound.x1:roibound.x2]
